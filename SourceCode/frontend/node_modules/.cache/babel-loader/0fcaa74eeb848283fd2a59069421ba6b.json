{"ast":null,"code":"import _objectSpread from \"/var/www/html/midOhio/fresh-trak/sourceCode/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/var/www/html/midOhio/fresh-trak/sourceCode/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useEffect } from \"react\";\nimport { required, max, min } from \"./FormValidation\";\n\nconst UseForm = (props, validations, callback) => {\n  const _useState = useState({}),\n        _useState2 = _slicedToArray(_useState, 2),\n        errors = _useState2[0],\n        setErrors = _useState2[1];\n\n  const formValidation = (value, validator, limit) => {\n    switch (validator) {\n      case \"required\":\n        return value.length > 0 ? \"\" : \"This value is required\";\n\n      case \"min\":\n        return value.length >= limit ? \"\" : `This value needs to be at least ${limit} characters`;\n\n      case \"max\":\n        return value.length <= limit ? \"\" : `This value cannot be more than ${limit} characters`;\n\n      default:\n        return \"\";\n    }\n  };\n\n  const handleErrors = e => {\n    if (typeof e.target === \"undefined\") {\n      let data = e;\n      let count = 0;\n\n      for (let key in data) {\n        // get index and check for last index and set true\n        let keyExists = key in validations;\n\n        if (keyExists) {\n          count++;\n\n          if (count === Object.keys(validations).length) {\n            let loopFinish = processValidations(data[key], validations[key], key, true);\n            return loopFinish;\n          } else {\n            processValidations(data[key], validations[key], key);\n          }\n        }\n      }\n    } else {\n      let _e$target = e.target,\n          name = _e$target.name,\n          value = _e$target.value;\n      let nameExists = name in validations;\n\n      if (nameExists) {\n        processValidations(value, validations[name], name);\n      }\n    }\n  };\n\n  const processValidations = (value, validate, name, lastLoop) => {\n    let validationRes;\n    let validator;\n    let limit;\n    let count = 0;\n\n    for (let i = 0; i < validate.length; i++) {\n      count++;\n      let splitKey = validate[i].split(':');\n\n      if (typeof splitKey[1] !== 'undefined') {\n        validator = splitKey[0];\n        limit = splitKey[1];\n      } else {\n        validator = validate[i];\n      }\n\n      if (typeof validator === \"string\") {\n        validationRes = formValidation(value, validator, limit);\n      }\n\n      if (validationRes) break;\n    }\n\n    setErrors(errors => _objectSpread({}, errors, {\n      [name]: validationRes\n    }));\n\n    if (count >= 1 && lastLoop) {\n      if (validationRes) {\n        return true;\n      }\n\n      return false;\n    }\n  };\n\n  useEffect(() => {\n    for (let keys in errors) {\n      if (errors[keys] === null || errors[keys] === \"\") {\n        delete errors[keys];\n      }\n    }\n\n    if (Object.keys(errors).length === 0) {\n      callback();\n    }\n\n    props.onFormErrors(errors);\n  }, [errors]);\n  return {\n    handleErrors,\n    errors\n  };\n};\n\nexport default UseForm;","map":{"version":3,"sources":["/var/www/html/midOhio/fresh-trak/sourceCode/frontend/src/Utils/UseForm.js"],"names":["useState","useEffect","required","max","min","UseForm","props","validations","callback","errors","setErrors","formValidation","value","validator","limit","length","handleErrors","e","target","data","count","key","keyExists","Object","keys","loopFinish","processValidations","name","nameExists","validate","lastLoop","validationRes","i","splitKey","split","onFormErrors"],"mappings":"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","sourcesContent":["import { useState, useEffect } from \"react\";\nimport {required, max, min} from \"./FormValidation\";\n\nconst UseForm = (props, validations, callback) => {\n    const [errors, setErrors] = useState({});\n\n    const formValidation = (value, validator, limit) => {\n        switch (validator) {\n            case \"required\":\n                return value.length > 0 ? \"\" : \"This value is required\";\n            case \"min\":\n                return value.length >= limit\n                    ? \"\"\n                    : `This value needs to be at least ${limit} characters`;\n            case \"max\":\n                return value.length <= limit\n                    ? \"\"\n                    : `This value cannot be more than ${limit} characters`;\n            default:\n                return \"\";\n        }\n    };\n\n    const handleErrors = (e) => {\n        if (typeof e.target === \"undefined\") {\n            let data = e;\n            let count = 0;\n            for(let key in data){\n                // get index and check for last index and set true\n                let keyExists = key in validations;\n                if(keyExists){\n                    count++;\n                    if(count === Object.keys(validations).length){\n                        let loopFinish = processValidations(data[key], validations[key], key, true);\n                        return loopFinish\n                    }else{\n                        processValidations(data[key], validations[key], key);\n                    }\n\n                }\n            }\n        }else{\n            let {name, value} = e.target;\n            let nameExists = name in validations;\n            if(nameExists){\n                processValidations(value, validations[name], name);\n            }\n        }\n\n    };\n\n\n    const processValidations = (value, validate, name, lastLoop) => {\n        let validationRes;\n        let validator;\n        let limit;\n        let count = 0;\n\n        for (let i = 0; i < validate.length; i++) {\n            count++;\n            let splitKey = validate[i].split(':');\n            if(typeof splitKey[1] !== 'undefined'){\n                validator = splitKey[0];\n                limit = splitKey[1];\n            }else{\n                validator = validate[i];\n            }\n\n            if (typeof validator === \"string\") {\n                validationRes = formValidation(value, validator, limit);\n            }\n            if (validationRes) break;\n        }\n\n        setErrors(errors => ({\n            ...errors,\n            [name]: validationRes\n        }));\n\n        if(count >= 1 && lastLoop){\n            if(validationRes){\n                return true;\n            }\n            return false;\n        }\n    };\n\n    useEffect(() => {\n        for(let keys in errors){\n            if(errors[keys] === null || errors[keys] === \"\"){\n                delete errors[keys]\n            }\n        }\n\n        if(Object.keys(errors).length === 0){\n            callback();\n        }\n\n        props.onFormErrors(errors);\n\n    }, [errors]);\n\n\n\n    return {\n        handleErrors,\n        errors\n    };\n};\n\nexport default UseForm;\n"]},"metadata":{},"sourceType":"module"}